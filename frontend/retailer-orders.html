<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Retailer Orders - GrassRoots</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="js/utils.js"></script>
  <style>
    .container{max-width:1100px;margin:24px auto;padding:0 16px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid #eee}
    .btn{background:var(--primary-color);color:#fff;padding:8px 12px;border-radius:8px;border:none}
    body { background: #ecf5ee; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial }
    .page-wrapper { display:flex; justify-content:center; padding:80px 16px 40px 16px; min-height:100vh }
    .card { width:100%; max-width:960px; background: #fff; border-radius:10px; padding:24px 28px; box-shadow: 0 10px 30px rgba(0,0,0,0.06) }
    .card h1 { margin-top:0; color: #2f6b50 }
    .muted { color:#6b7b6b; margin-top:6px }
  </style>
</head>
<body>
  <nav class="navbar"><div class="nav-container container"><a href="index.html" class="logo">GrassRoots</a><div class="nav-links"><a href="retailer-dashboard.html">Dashboard</a><a href="retailer-products.html">Products</a><a href="retailer-payments.html">Payments</a><a href="retailer-profile.html">Profile</a></div></div></nav>

  <div class="page-wrapper">
    <div class="card">
      <h1>Orders</h1>
      <p class="muted">View and manage incoming orders.</p>
      <table id="ordersTable"><thead><tr><th>Order ID</th><th>Items</th><th>Total</th><th>Status</th><th>Actions</th></tr></thead><tbody></tbody></table>
      <div style="margin-top:16px;text-align:right;">
        <button class="btn" onclick="openNewOrder()">+ New Order</button>
      </div>

      <!-- New Order Modal -->
      <div id="orderModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); align-items:center; justify-content:center;">
        <div style="background:#fff; padding:20px; border-radius:8px; max-width:800px; width:95%; margin:40px auto;">
          <h3>Create New Order</h3>
          <div id="orderProductsList" style="max-height:400px; overflow:auto; margin-top:8px;"></div>
          <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
            <button class="btn" onclick="submitNewOrder()">Place Order</button>
            <button class="btn" onclick="closeOrderModal()">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Auto-detect backend URL based on current page
    const BACKEND_URL = window.location.protocol === 'file:'
      ? 'http://localhost:4000'
      : `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;

    async function loadOrders() {
      if (window.location.protocol === 'file:') {
        return JSON.parse(localStorage.getItem('retailer_orders') || '[]');
      }
      try {
        const resp = await GrassRootsUtils.apiFetch('/api/orders');
        if (!resp || !resp.ok) throw new Error('Failed to load orders');
        return await resp.json();
      } catch (err) {
        console.warn('Failed to fetch orders from server, falling back to localStorage', err);
        return JSON.parse(localStorage.getItem('retailer_orders') || '[]');
      }
    }

    async function loadProducts() {
      if (window.location.protocol === 'file:') {
        return JSON.parse(localStorage.getItem('retailer_products') || '[]');
      }
      try {
        const resp = await GrassRootsUtils.apiFetch('/api/products');
        if (!resp || !resp.ok) throw new Error('Failed to load products');
        const data = await resp.json();
        if (Array.isArray(data) && data.length > 0) return data;
        throw new Error('No products returned from backend');
      } catch (err) {
        console.warn('Failed to fetch products from server, falling back to localStorage', err);
        return JSON.parse(localStorage.getItem('retailer_products') || '[]');
      }
    }

    async function render() {
      const rows = document.querySelector('#ordersTable tbody');
      rows.innerHTML = '';
      const orders = await loadOrders();
      const products = await loadProducts();
      const productMap = {};
      (products || []).forEach(p => { productMap[String(p.id)] = p; if (typeof p.id === 'number') productMap[String(Number(p.id))] = p; });

      // find any productIds in orders that are missing from productMap
      const missingIds = new Set();
      (orders || []).forEach(o => {
        (o.items || []).forEach(i => {
          const pid = i.productId !== undefined ? String(i.productId) : (i.product_id !== undefined ? String(i.product_id) : null);
          if (pid && !productMap[pid]) missingIds.add(pid);
        });
      });

      // fetch missing products from backend (if any)
      if (missingIds.size > 0) {
        await Promise.all(Array.from(missingIds).map(async (pid) => {
          try {
            const resp = await GrassRootsUtils.apiFetch(`/api/products/${pid}`);
            if (resp && resp.ok) {
              const p = await resp.json();
              productMap[String(p.id)] = p;
            }
          } catch (e) {
            // ignore
          }
        }));
      }

      orders.forEach(o => {
        const tr = document.createElement('tr');
        const items = o.items || [];
        const itemsText = items.length > 0 ? items.map(i => {
          const name = i.name || (productMap[String(i.productId)] && productMap[String(i.productId)].name) || i.productId || 'Unknown';
          const qty = i.qty !== undefined ? i.qty : (i.quantity || 0);
          return `${name} x${qty}`;
        }).join('<br>') : 'No items';
        const total = o.total || 0;
        tr.innerHTML = `<td>${o.id || o.orderNumber || 'N/A'}</td><td>${itemsText}</td><td>₹ ${Number(total).toFixed(2)}</td><td>${o.status || 'pending'}</td><td><button class='btn' onclick="view('${o.id}')">View</button></td>`;
        rows.appendChild(tr);
      });
    }

    async function seed() {
      const existing = await loadOrders();
      if (existing.length) return;
      const prods = await loadProducts();
      if (!prods || prods.length === 0) {
        console.log('No products available to seed orders');
        return;
      }
      const sample = [{
        id: 'o_' + Date.now(),
        items: prods.slice(0, 2).map(p => ({ productId: p.id, name: p.name, qty: 1, price: p.price })),
        total: prods.slice(0, 2).reduce((s, p) => s + (p.price || 0), 0),
        status: 'Pending',
        paid: false
      }];
      try {
        for (const o of sample) {
          await GrassRootsUtils.apiFetch('/api/orders', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(o) });
        }
        console.log('Sample order seeded');
        await render();
      } catch (err) {
        console.error('Failed to seed orders:', err);
        localStorage.setItem('retailer_orders', JSON.stringify(sample));
        console.log('Seeded locally');
        await render();
      }
    }

    async function view(id) {
      if (window.location.protocol === 'file:') {
        // Load order from localStorage
        const orders = JSON.parse(localStorage.getItem('retailer_orders') || '[]');
        const o = orders.find(x => x.id === id);
        if (!o) return alert('Order not found');
        const details = `Order ${o.id}\nItems:\n${(o.items || []).map(i => i.name + ' x' + i.qty).join('\n')}\nTotal: ₹ ${o.total.toFixed(2)}\nStatus: ${o.status}\nPaid: ${o.paid ? 'Yes' : 'No'}`;
        alert(details);
        return;
      }
      try {
        const resp = await GrassRootsUtils.apiFetch(`/api/orders/${id}`);
        if (!resp || !resp.ok) throw new Error('Order not found');
        const data = await resp.json();
        const o = data.order || data;
        const products = await loadProducts();
        const productMap = {};
        (products || []).forEach(p => { productMap[String(p.id)] = p; });

        // fetch any missing products referenced by this order
        const missing = new Set();
        (data.items || o.items || []).forEach(i => {
          const pid = i.productId !== undefined ? String(i.productId) : (i.product_id !== undefined ? String(i.product_id) : null);
          if (pid && !productMap[pid]) missing.add(pid);
        });
        if (missing.size > 0) {
          await Promise.all(Array.from(missing).map(async pid => {
            try {
              const r = await GrassRootsUtils.apiFetch(`/api/products/${pid}`);
              if (r && r.ok) {
                const p = await r.json();
                productMap[String(p.id)] = p;
              }
            } catch (e) { /* ignore */ }
          }));
        }

        const itemsList = (data.items || o.items || []).map(i => {
          const name = i.name || (productMap[String(i.productId)] && productMap[String(i.productId)].name) || i.productId || 'Unknown';
          const qty = i.qty !== undefined ? i.qty : (i.quantity || 0);
          return `${name} x${qty}`;
        });
        const details = `Order ${o.id}\nItems:\n${itemsList.join('\n')}\nTotal: ₹ ${o.total.toFixed(2)}\nStatus: ${o.status}\nPaid: ${o.paid ? 'Yes' : 'No'}`;
        if (confirm(details + '\n\nMark Confirmed?')) {
          updateStatus(id, 'Confirmed');
        }
      } catch (err) {
        console.error('Failed to load order:', err);
      }
    }

    // New order UI
    function openNewOrder() {
      document.getElementById('orderModal').style.display = 'flex';
      renderOrderProductList();
    }

    function closeOrderModal() {
      document.getElementById('orderModal').style.display = 'none';
    }

    async function renderOrderProductList() {
      const container = document.getElementById('orderProductsList');
      container.innerHTML = '';
      const products = await loadProducts();
      if (!products || products.length === 0) {
        container.innerHTML = '<p style="color:#666;">No products available</p>';
        return;
      }
      products.forEach(p => {
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center'; row.style.padding = '8px 0';
        row.innerHTML = `<div style="flex:1"><strong>${GrassRootsUtils.sanitizeHTML(p.name)}</strong> <div style="color:#666;font-size:0.9rem;">₹ ${Number(p.price).toFixed(2)} | ${p.stock} kg available</div></div><div><input type="number" min="0" max="${p.stock||0}" placeholder="0" style="width:80px;padding:6px;border-radius:6px;border:1px solid #ddd;" data-pid="${p.id}" data-price="${p.price}" /></div>`;
        container.appendChild(row);
      });
    }

    async function submitNewOrder() {
      const inputs = Array.from(document.querySelectorAll('#orderProductsList input'));
      const items = inputs.map(i => ({ productId: i.dataset.pid, qty: parseInt(i.value) || 0, price: parseFloat(i.dataset.price) || 0 })).filter(x => x.qty > 0);
      if (!items.length) return alert('Please add at least one product to the order');
      const total = items.reduce((s, it) => s + (it.qty * (it.price||0)), 0);
      const order = { id: 'o_' + Date.now(), items: items.map(it => ({ productId: it.productId, name: '', qty: it.qty, price: it.price })), total, status: 'Pending', paid: false };
      // fetch product names to include
      const prods = await loadProducts();
      order.items = order.items.map(it => {
        const p = prods.find(x => x.id === it.productId) || {};
        return { ...it, name: p.name || it.productId };
      });

      if (window.location.protocol === 'file:') {
        // Save order to localStorage
        const orders = JSON.parse(localStorage.getItem('retailer_orders') || '[]');
        orders.push(order);
        localStorage.setItem('retailer_orders', JSON.stringify(orders));
        closeOrderModal();
        await render();
        alert('Order placed');
        return;
      }

      try {
        const resp = await GrassRootsUtils.apiFetch('/api/orders', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(order) });
        if (!resp || !resp.ok) throw new Error('Failed to create order');

        // Also save to localStorage as backup
        try {
          const orders = JSON.parse(localStorage.getItem('retailer_orders') || '[]');
          orders.push(order);
          localStorage.setItem('retailer_orders', JSON.stringify(orders));
        } catch (e) {
          console.warn('Failed to save to localStorage:', e);
        }

        closeOrderModal();
        await render();
        alert('Order placed');
      } catch (err) {
        console.error('Failed to place order:', err);
        // Fallback to localStorage if backend fails
        try {
          const orders = JSON.parse(localStorage.getItem('retailer_orders') || '[]');
          orders.push(order);
          localStorage.setItem('retailer_orders', JSON.stringify(orders));
          closeOrderModal();
          await render();
          alert('Order placed (saved locally)');
        } catch (e2) {
          alert('Failed to place order');
        }
      }
    }

    async function updateStatus(id, status) {
      try {
        // Update order status on server
        const resp = await GrassRootsUtils.apiFetch(`/api/orders/${id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status }) });
        if (!resp || !resp.ok) throw new Error('Failed to update order');

        if (status === 'Confirmed') {
          // decrement product stock for each order item
          const resp2 = await GrassRootsUtils.apiFetch(`/api/orders/${id}`);
          if (resp2 && resp2.ok) {
            const data = await resp2.json();
            const items = data.items || data.order && data.order.items || [];
            for (const it of items) {
              try {
                // fetch product
                const pResp = await GrassRootsUtils.apiFetch(`/api/products/${it.productId}`);
                if (!pResp || !pResp.ok) continue;
                const p = await pResp.json();
                const newStock = Math.max(0, (p.stock || 0) - (it.qty || 0));
                await GrassRootsUtils.apiFetch(`/api/products/${p.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ stock: newStock }) });
              } catch (e) {
                console.warn('Failed to update product stock for', it.productId, e);
              }
            }
          }
        }

        await render();
        alert('Status updated');
      } catch (err) {
        console.error('Failed to update status:', err);
        alert('Failed to update status');
      }
    }

    document.addEventListener('DOMContentLoaded', function() { render(); seed(); });
  </script>
</body>
</html>
